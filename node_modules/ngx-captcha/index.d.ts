import * as i0 from '@angular/core';
import { NgZone, OnChanges, AfterViewInit, AfterViewChecked, Renderer2, Injector, EventEmitter, ElementRef, SimpleChanges, OnDestroy } from '@angular/core';
import { ControlValueAccessor, AbstractControl } from '@angular/forms';
import * as i3 from '@angular/common';

declare enum ReCaptchaType {
    InvisibleReCaptcha = 0,
    ReCaptcha2 = 1
}

interface RecaptchaConfiguration {
    useGlobalDomain?: boolean;
    useEnterprise?: boolean;
}

declare class ScriptService {
    protected zone: NgZone;
    private readonly scriptElemId;
    /**
     * Name of the global google recaptcha script
     */
    protected readonly windowGrecaptcha = "grecaptcha";
    /**
     * Name of enterpise property in the global google recaptcha script
     */
    protected readonly windowGrecaptchaEnterprise = "enterprise";
    /**
     * Name of the global callback
     */
    protected readonly windowOnLoadCallbackProperty = "ngx_captcha_onload_callback";
    /**
     * Name of the global callback for enterprise
     */
    protected readonly windowOnLoadEnterpriseCallbackProperty = "ngx_captcha_onload_enterprise_callback";
    protected readonly globalDomain: string;
    protected readonly defaultDomain: string;
    protected readonly enterpriseApi: string;
    protected readonly defaultApi: string;
    constructor(zone: NgZone);
    registerCaptchaScript(config: RecaptchaConfiguration, render: string, onLoad: (grecaptcha: any) => void, language?: string): void;
    cleanup(): void;
    /**
     * Indicates if google recaptcha script is available and ready to be used
     */
    private grecaptchaScriptLoaded;
    /**
     * Gets global callback name
     * @param useEnterprise Optional flag for enterprise script
     * @private
     */
    private getCallbackName;
    /**
     * Gets language param used in script url
     */
    private getLanguageParam;
    /**
     * Url to google api script
     */
    private getCaptchaScriptUrl;
    static ɵfac: i0.ɵɵFactoryDeclaration<ScriptService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ScriptService>;
}

declare abstract class BaseReCaptchaComponentDirective implements OnChanges, ControlValueAccessor, AfterViewInit, AfterViewChecked {
    protected renderer: Renderer2;
    protected zone: NgZone;
    protected injector: Injector;
    protected scriptService: ScriptService;
    /**
     * Prefix of the captcha element
     */
    protected readonly captchaElemPrefix = "ngx_captcha_id_";
    private setupCaptcha;
    /**
     * Google's site key.
     * You can find this under https://www.google.com/recaptcha
     */
    siteKey?: string;
    /**
     * Indicates if global domain 'recaptcha.net' should be used instead of default domain ('google.com')
     */
    useGlobalDomain: boolean;
    useEnterprise: boolean;
    /**
     * Type
     */
    type: "audio" | "image";
    /**
     * Language code. Auto-detects the user's language if unspecified.
     */
    hl?: string;
    /**
     * Tab index
     */
    tabIndex: number;
    /**
     * Called when captcha receives successful response.
     * Captcha response token is passed to event.
     */
    success: EventEmitter<string>;
    /**
     * Called when captcha is loaded. Event receives id of the captcha
     */
    load: EventEmitter<void>;
    /**
     * Called when captcha is reset.
     */
    reset: EventEmitter<void>;
    /**
     * Called when captcha is loaded & ready. I.e. when you need to execute captcha on component load.
     */
    ready: EventEmitter<void>;
    /**
     * Error callback
     */
    error: EventEmitter<void>;
    /**
     * Expired callback
     */
    expire: EventEmitter<void>;
    abstract captchaWrapperElem?: ElementRef;
    /**
     * Indicates if captcha should be set on load
     */
    private setupAfterLoad;
    /**
     * Captcha element
     */
    protected captchaElem?: HTMLElement;
    /**
     * Id of the captcha elem
     */
    protected captchaId?: number;
    /**
     * Holds last response value
     */
    protected currentResponse?: string;
    /**
     * If enabled, captcha will reset after receiving success response. This is useful
     * when invisible captcha need to be resolved multiple times on same page
     */
    protected resetCaptchaAfterSuccess: boolean;
    /**
     * Captcha type
     */
    protected abstract recaptchaType: ReCaptchaType;
    /**
     * Required by ControlValueAccessor
     */
    protected onChange: (value: string | undefined) => void;
    protected onTouched: (value: string | undefined) => void;
    /**
     * Indicates if captcha is loaded
     */
    isLoaded: boolean;
    /**
     * Reference to global reCaptcha API
     */
    reCaptchaApi?: any;
    /**
     * Id of the DOM element wrapping captcha
     */
    captchaElemId?: string;
    /**
     * Form Control to be enable usage in reactive forms
     */
    control?: AbstractControl | null;
    protected constructor(renderer: Renderer2, zone: NgZone, injector: Injector, scriptService: ScriptService);
    ngAfterViewInit(): void;
    ngAfterViewChecked(): void;
    /**
     * Gets reCaptcha properties
     */
    protected abstract getCaptchaProperties(): any;
    /**
     * Used for captcha specific setup
     */
    protected abstract captchaSpecificSetup(): void;
    ngOnChanges(changes: SimpleChanges): void;
    /**
     * Gets captcha response as per reCaptcha docs
     */
    getResponse(): string;
    /**
     * Gets Id of captcha widget
     */
    getCaptchaId(): number | undefined;
    /**
     * Resets captcha
     */
    resetCaptcha(): void;
    /**
     * Gets last submitted captcha response
     */
    getCurrentResponse(): string | undefined;
    /**
     * Reload captcha. Useful when properties (i.e. theme) changed and captcha need to reflect them
     */
    reloadCaptcha(): void;
    protected ensureCaptchaElem(captchaElemId: string): void;
    /**
     * Responsible for instantiating captcha element
     */
    protected renderReCaptcha(): void;
    /**
     * Called when captcha receives response
     * @param callback Callback
     */
    protected handleCallback(callback: any): void;
    private getPseudoUniqueNumber;
    private setupComponent;
    /**
     * Called when google's recaptcha script is ready
     */
    private onloadCallback;
    private generateNewElemId;
    private createAndSetCaptchaElem;
    /**
     * To be aligned with the ControlValueAccessor interface we need to implement this method
     * However as we don't want to update the recaptcha, this doesn't need to be implemented
     */
    writeValue(obj: any): void;
    /**
     * This method helps us tie together recaptcha and our formControl values
     */
    registerOnChange(fn: any): void;
    /**
     * At some point we might be interested whether the user has touched our component
     */
    registerOnTouched(fn: any): void;
    /**
     * Handles error callback
     */
    protected handleErrorCallback(): void;
    /**
     * Handles expired callback
     */
    protected handleExpireCallback(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<BaseReCaptchaComponentDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<BaseReCaptchaComponentDirective, never, never, { "siteKey": { "alias": "siteKey"; "required": false; }; "useGlobalDomain": { "alias": "useGlobalDomain"; "required": false; }; "useEnterprise": { "alias": "useEnterprise"; "required": false; }; "type": { "alias": "type"; "required": false; }; "hl": { "alias": "hl"; "required": false; }; "tabIndex": { "alias": "tabIndex"; "required": false; }; }, { "success": "success"; "load": "load"; "reset": "reset"; "ready": "ready"; "error": "error"; "expire": "expire"; }, never, never, true, never>;
}

declare class InvisibleReCaptchaComponent extends BaseReCaptchaComponentDirective implements OnChanges {
    protected renderer: Renderer2;
    protected zone: NgZone;
    protected injector: Injector;
    protected scriptService: ScriptService;
    /**
     * This size representing invisible captcha
     */
    protected readonly size = "invisible";
    /**
     * Theme
     */
    theme: 'dark' | 'light';
    /**
     * Badge
     */
    badge: 'bottomright' | 'bottomleft' | 'inline';
    captchaWrapperElem?: ElementRef;
    protected recaptchaType: ReCaptchaType;
    constructor(renderer: Renderer2, zone: NgZone, injector: Injector, scriptService: ScriptService);
    ngOnChanges(changes: SimpleChanges): void;
    /**
     * Programatically invoke the reCAPTCHA check. Used if the invisible reCAPTCHA is on a div instead of a button.
     */
    execute(): void;
    protected captchaSpecificSetup(): void;
    /**
    * Gets reCaptcha properties
    */
    protected getCaptchaProperties(): any;
    static ɵfac: i0.ɵɵFactoryDeclaration<InvisibleReCaptchaComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<InvisibleReCaptchaComponent, "ngx-invisible-recaptcha", never, { "theme": { "alias": "theme"; "required": false; }; "badge": { "alias": "badge"; "required": false; }; }, {}, never, never, false, never>;
}

declare class ReCaptcha2Component extends BaseReCaptchaComponentDirective implements OnChanges, OnDestroy {
    protected renderer: Renderer2;
    protected zone: NgZone;
    protected injector: Injector;
    protected scriptService: ScriptService;
    /**
    * Name of the global expire callback
    */
    protected readonly windowOnErrorCallbackProperty = "ngx_captcha_error_callback";
    /**
    * Name of the global error callback
    */
    protected readonly windowOnExpireCallbackProperty = "ngx_captcha_expire_callback";
    /**
     * Theme
     */
    theme: 'dark' | 'light';
    /**
    * Size
    */
    size: 'compact' | 'normal';
    captchaWrapperElem?: ElementRef;
    protected recaptchaType: ReCaptchaType;
    constructor(renderer: Renderer2, zone: NgZone, injector: Injector, scriptService: ScriptService);
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    protected captchaSpecificSetup(): void;
    /**
     * Gets reCaptcha properties
    */
    protected getCaptchaProperties(): any;
    /**
     * Registers global callbacks
    */
    private registerCallbacks;
    static ɵfac: i0.ɵɵFactoryDeclaration<ReCaptcha2Component, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ReCaptcha2Component, "ngx-recaptcha2", never, { "theme": { "alias": "theme"; "required": false; }; "size": { "alias": "size"; "required": false; }; }, {}, never, never, false, never>;
}

declare class ReCaptchaV3Service {
    protected scriptService: ScriptService;
    protected zone: NgZone;
    constructor(scriptService: ScriptService, zone: NgZone);
    /**
     * Executes reCaptcha v3/Enterprise with given action and passes token via callback. You need to verify
     * this callback in your backend to get meaningful results.
     *
     * For more information see https://developers.google.com/recaptcha/docs/v3
     * For enterprise see https://cloud.google.com/recaptcha-enterprise/docs
     *
     * @param siteKey Site key found in your google admin panel
     * @param action Action to log
     * @param callback Callback function to to handle token
     * @param config Optional configuration like useGlobalDomain to be provided
     * @param errorCallback Optional Callback function to handle errors
     */
    execute(siteKey: string, action: string, callback: (token: string) => void, config?: RecaptchaConfiguration, errorCallback?: (error: any) => void): void;
    /**
     * Executes reCaptcha v3/Enterprise with given action and returns token via Promise. You need to verify
     * this token in your backend to get meaningful results.
     *
     * For more information see https://developers.google.com/recaptcha/docs/v3
     * For enterprise see https://cloud.google.com/recaptcha-enterprise/docs
     *
     * @param siteKey Site key found in your google admin panel
     * @param action Action to log
     * @param config Optional configuration like useGlobalDomain to be provided
     */
    executeAsPromise(siteKey: string, action: string, config?: RecaptchaConfiguration): Promise<string>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ReCaptchaV3Service, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ReCaptchaV3Service>;
}

declare class NgxCaptchaModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxCaptchaModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NgxCaptchaModule, [typeof ReCaptcha2Component, typeof InvisibleReCaptchaComponent], [typeof i3.CommonModule], [typeof ReCaptcha2Component, typeof InvisibleReCaptchaComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NgxCaptchaModule>;
}

export { BaseReCaptchaComponentDirective, InvisibleReCaptchaComponent, NgxCaptchaModule, ReCaptcha2Component, ReCaptchaType, ReCaptchaV3Service, ScriptService };
//# sourceMappingURL=index.d.ts.map
